@using Microsoft.Extensions.DependencyInjection
@using iPath.Application.Fhir
@using iPath.Domain.Entities.Base

@namespace iPath.Blazor.Componenents.Shared.Coding

<MudPaper Class="pa-2">
    <h3>@T["Body site filter (icd-o)"]</h3>
    @if (RendererInfo.IsInteractive)
    {
        <MudStack AlignItems="AlignItems.Start">
            <MudTextField T="string" Label="Search" Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          TextChanged="OnTextChanged" Immediate="true" Clearable="true" />
            <CodingTreeFilter TreeItems="BodySiteCodes" @ref="_treeView"
                              @bind-SelectedValues="SelectedValues" />

        </MudStack>
        <div style="border: 1px; margin-top: 8px;">
            <strong>selection: </strong> @sel
        </div>
    }
    else
    {
        <MudSkeleton Height="200px" />
    }
</MudPaper>

@inject IServiceProvider sp;

    @code {
    [Parameter]
    public ConceptFilter? Filter { get; set; }

    [Parameter]
    public EventCallback<ConceptFilter?> FilterChanged { get; set; }


    CodingTreeFilter _treeView;
    IReadOnlyCollection<CodeDisplay> SelectedValues { get; set; } = [];

    string sel => SelectedValues is null ? "--" : string.Join(", ", SelectedValues.Select(x => x.Code).ToArray());

    public List<TreeItemData<CodeDisplay>> BodySiteCodes { get; private set; } = new();

    const string system = "icdo";
    const string vsid = "icdo-topo";

    /*
    async Task OnSelectionChange()
    {
        StateHasChanged();
        var list = SelectedValues.ToArray().ToConcept(_coding.CodeSystemUrl).ToList();
        if (list.IsEmpty())
        {
            Filter = null;
        }
        else
        {
            Filter = new() { Concetps = list };
        }
        await FilterChanged.InvokeAsync(Filter);
    }
    */


    CodingService _coding;
    ValueSetDisplay _valueset;
    protected override async Task OnInitializedAsync()
    {
        _coding = sp.GetRequiredKeyedService<CodingService>(system);
        var _loader = sp.GetRequiredService<IFhirDataLoader>();

        // TODO: initilize in DI startup
        await _coding.LoadCodeSystem();
        await _coding.LoadValueSet(vsid);
        _valueset = _coding.GetValueSetDisplay(vsid);

        // if only one root node => start with it's childrend
        // TODO: write an extension that finds the first node with more than 1 child
        if (_valueset.DisplayTree.Count == 1)
        {
            BodySiteCodes = _valueset.DisplayTree.First().Children.ToTreeView();
        }
        else
        {
            BodySiteCodes = _valueset.DisplayTree.ToTreeView();
        }

        LoadFilter();
    }

    private void LoadFilter()
    {
        if (Filter is not null && _valueset is not null)
        {
            var mysel = new List<CodeDisplay>();
            foreach (var code in Filter.Concetps)
            {
                var expanded = _coding.GetChildCodes(code.Code, true);
                foreach (var x in expanded.ChildCodes) 
                {
                    mysel.Add(_valueset.FindConceptByCode(x));
                } 
            }
            SelectedValues = mysel;
        }
        else
        {
            SelectedValues = new List<CodeDisplay>();
        }
        StateHasChanged();
    }

    public void SaveFilter()
    {
        // Build a lookup of selected codes
        var selectedCodes = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (SelectedValues is not null)
        {
            foreach (var v in SelectedValues)
            {
                if (v?.Code is not null)
                    selectedCodes.Add(v.Code);
            }
        }

        var _selection = new List<CodeDisplay>();

        // Recursive helper: determines whether all nodes in the subtree are selected.
        bool NodeFullySelected(ITreeItemData<CodeDisplay> node)
        {
            var children = node.Children;
            if (children is null)
            {
                // leaf node
                return node.Value?.Code is not null && selectedCodes.Contains(node.Value.Code);
            }

            bool hadChild = false;
            foreach (var child in children)
            {
                hadChild = true;
                if (!NodeFullySelected(child))
                    return false;
            }

            // no children -> treat as leaf
            if (!hadChild)
                return node.Value?.Code is not null && selectedCodes.Contains(node.Value.Code);

            // all children fully selected
            return true;
        }

        // Traverse and collect: if a node's entire subtree is selected, add only the parent and skip children.
        void Traverse(ITreeItemData<CodeDisplay> node)
        {
            if (NodeFullySelected(node))
            {
                if (node.Value is not null)
                    _selection.Add(node.Value);
                return;
            }

            // If node itself was selected (but not all children), include it as well.
            if (node.Value is not null && selectedCodes.Contains(node.Value.Code ?? string.Empty))
                _selection.Add(node.Value);

            if (node.Children is not null)
            {
                foreach (var child in node.Children)
                    Traverse(child);
            }
        }

        if (BodySiteCodes is not null)
        {
            foreach (var root in BodySiteCodes)
            {
                // TreeItemData implements ITreeItemData<T>, so cast is safe
                Traverse(root);
            }
        }


        if (_selection.IsEmpty())
        {
            Filter = null;
        }
        else
        {
            Filter.Concetps = _selection.ToConcept(_coding.CodeSystemUrl).ToList();
        }
    }


    private async Task OnTextChanged(string term)
    {
        await _treeView.Search(term);
    }
}
